<html><body bgcolor="#ccffcc" text="#000000"><table><tr><td colspan="2"><h3>Problem Statement</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><p>
An ordered binary tree is a rooted binary tree in which each node X contains two pointers: X.left and X.right.
Each of these pointers either points to the corresponding child node, or it has a special value "None" meaning that node X doesn't have the corresponding child.
</p>

<p>
I just taught Antonio some tree traversal techniques on ordered binary trees.
I asked him to implement these tree traversals but I don't think he was paying attention, since he mixed them up and wrote the following pseudocode:
</p>

<pre>
def order(v, mode):
    if v == None:
        return []
    if mode == "pre":
       return [v.label] + order(v.left, s[0]) + order(v.right, s[1])
    if mode == "in":
       return order(v.left, s[2]) + [v.label] + order(v.right, s[3])
    if mode == "post":
       return order(v.left, s[4]) + order(v.right, s[5]) + [v.label]
</pre>

<p>
You are given the vector &lt;string&gt; <b>s</b> used in the pseudocode above.
You are guaranteed that among {<b>s</b>[0], <b>s</b>[2], <b>s</b>[4]} and also among {<b>s</b>[1], <b>s</b>[3], <b>s</b>[5]} each of the strings "pre", "in", and "post" appears exactly once.
</p>

<p>
I have a rooted binary tree with n nodes.
The nodes of the tree are labeled 1 through n, in no particular order.
The root of the tree is stored in a variable called root.
</p>

<p>
You are given strings <b>e1</b> and <b>e2</b>.
It is guaranteed that these are two of the three strings "pre", "in", and "post".
Let e3 be the third, unused string.
</p>

<p>
You are also given vector &lt;int&gt;s <b>a1</b> and <b>a2</b>, each of length n, and each containing a permutation of numbers 1 through n.
</p>

<p>
Consider the scenario in which we executed Antonio's code twice, as follows:
</p>
<pre>
a1 = order(root, e1)
a2 = order(root, e2)
</pre>

<p>
Is there a tree for which this scenario is possible?
If there is no tree that corresponds to the given <b>a1</b>, <b>a2</b>, <b>e1</b>, and <b>e2</b>, return an empty vector &lt;int&gt;.
Otherwise, suppose that we also executed the third matching command:
</p>

<pre>
a3 = order(root, e3)
</pre>

<p>
Find and return a3. If there are multiple solutions, you may return any of them.
</p></td></tr><tr><td colspan="2"><h3>Definition</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Class:</td><td>PreInPost</td></tr><tr><td>Method:</td><td>findMissing</td></tr><tr><td>Parameters:</td><td>vector &lt;string&gt;, vector &lt;int&gt;, vector &lt;int&gt;, string, string</td></tr><tr><td>Returns:</td><td>vector &lt;int&gt;</td></tr><tr><td>Method signature:</td><td>vector &lt;int&gt; findMissing(vector &lt;string&gt; s, vector &lt;int&gt; a1, vector &lt;int&gt; a2, string e1, string e2)</td></tr><tr><td colspan="2">(be sure your method is public)</td></tr></table></td></tr><tr><td colspan="2"><h3>Limits</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Time limit (s):</td><td>2.000</td></tr><tr><td>Memory limit (MB):</td><td>256</td></tr><tr><td>Stack limit (MB):</td><td>256</td></tr></table></td></tr><tr><td colspan="2"><h3>Constraints</h3></td></tr><tr><td align="center" valign="top">-</td><td><b>s</b> will contain exactly 6 elements.</td></tr><tr><td align="center" valign="top">-</td><td>Each element of <b>s</b> will be one of "pre", "in", "post".</td></tr><tr><td align="center" valign="top">-</td><td>Among {<b>s</b>[0], <b>s</b>[2], <b>s</b>[4]} and {<b>s</b>[1], <b>s</b>[3], <b>s</b>[5]}, each of "pre", "in", "post" appears exactly once.</td></tr><tr><td align="center" valign="top">-</td><td><b>a1</b> will have between 1 and 200 elements, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>a2</b> will have the same length as <b>a1</b>.</td></tr><tr><td align="center" valign="top">-</td><td>Both <b>a1,a2</b> will be a permutation of 1 to len(<b>a1</b>).</td></tr><tr><td align="center" valign="top">-</td><td><b>e1,e2</b> will each be one of "pre", "in", "post".</td></tr><tr><td align="center" valign="top">-</td><td><b>e1</b> will be different from <b>e2</b>.</td></tr><tr><td colspan="2"><h3>Examples</h3></td></tr><tr><td align="center" nowrap="true">0)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{&quot;post&quot;, &quot;in&quot;, &quot;pre&quot;, &quot;post&quot;, &quot;in&quot;, &quot;pre&quot;}</pre></td></tr><tr><td><pre>{1,2,3,4,5}</pre></td></tr><tr><td><pre>{2,4,3,5,1}
</pre></td></tr><tr><td><pre>&quot;pre&quot;</pre></td></tr><tr><td><pre>&quot;post&quot;</pre></td></tr></table></td></tr><tr><td><pre>Returns: {2, 1, 3, 5, 4 }</pre></td></tr><tr><td><table><tr><td colspan="2">Here you are supposed to return the result of <pre>order(root, "in")</pre>

The returned result corresponds to the following rooted tree:
 
<p>
<img src="http://www.topcoder.com/contest/problem/PreInPost/image2.png"></img>
</p>

Another possible answer is {4,2,3,1,5}, which corresponds to the following tree:

<p>
<img src="http://www.topcoder.com/contest/problem/PreInPost/image1.png"></img>
</p></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">1)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{&quot;post&quot;, &quot;in&quot;, &quot;pre&quot;, &quot;post&quot;, &quot;in&quot;, &quot;pre&quot;}</pre></td></tr><tr><td><pre>{2,1,3,5,4}</pre></td></tr><tr><td><pre>{1,2,3,4,5}</pre></td></tr><tr><td><pre>&quot;in&quot;</pre></td></tr><tr><td><pre>&quot;pre&quot;</pre></td></tr></table></td></tr><tr><td><pre>Returns: {2, 4, 3, 5, 1 }</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">2)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{&quot;pre&quot;, &quot;pre&quot;, &quot;in&quot;, &quot;in&quot;, &quot;post&quot;, &quot;post&quot;}</pre></td></tr><tr><td><pre>{1,2,3,4,5,6,7,8,9,10}</pre></td></tr><tr><td><pre>{10,9,8,7,6,5,4,3,2,1}</pre></td></tr><tr><td><pre>&quot;post&quot;</pre></td></tr><tr><td><pre>&quot;pre&quot;</pre></td></tr></table></td></tr><tr><td><pre>Returns: {10, 9, 8, 7, 6, 5, 4, 3, 2, 1 }</pre></td></tr><tr><td><table><tr><td colspan="2">It is allowed for nodes to have only one child.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">3)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{&quot;pre&quot;, &quot;pre&quot;, &quot;in&quot;, &quot;in&quot;, &quot;post&quot;, &quot;post&quot;}</pre></td></tr><tr><td><pre>{1}</pre></td></tr><tr><td><pre>{1}</pre></td></tr><tr><td><pre>&quot;post&quot;</pre></td></tr><tr><td><pre>&quot;in&quot;</pre></td></tr></table></td></tr><tr><td><pre>Returns: {1 }</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">4)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{&quot;pre&quot;, &quot;in&quot;, &quot;post&quot;, &quot;pre&quot;, &quot;in&quot;, &quot;post&quot;}</pre></td></tr><tr><td><pre>{9,3,4,1,6,5,2,7,8}</pre></td></tr><tr><td><pre>{3,9,1,4,2,7,8,5,6}</pre></td></tr><tr><td><pre>&quot;in&quot;</pre></td></tr><tr><td><pre>&quot;post&quot;</pre></td></tr></table></td></tr><tr><td><pre>Returns: {6, 1, 9, 3, 4, 5, 8, 7, 2 }</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">5)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{&quot;pre&quot;, &quot;in&quot;, &quot;in&quot;, &quot;post&quot;, &quot;post&quot;, &quot;pre&quot;}</pre></td></tr><tr><td><pre>{1,2,3}</pre></td></tr><tr><td><pre>{2,3,1}</pre></td></tr><tr><td><pre>&quot;post&quot;</pre></td></tr><tr><td><pre>&quot;pre&quot;</pre></td></tr></table></td></tr><tr><td><pre>Returns: { }</pre></td></tr><tr><td><table><tr><td colspan="2">In this case there is no solution.</td></tr></table></td></tr></table></td></tr></table><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc.  Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited.  (c)2003, TopCoder, Inc.  All rights reserved.  </p></body></html>
