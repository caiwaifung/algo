<html><body bgcolor="#ccffcc" text="#000000"><table><tr><td colspan="2"><h3>Problem Statement</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><p>Owaski is another pet dog of Zhangzj. He likes playing on a tree.</p>

<p>The tree has N vertices, labeled from 0 to N - 1. You are given an vector &lt;int&gt; parent of N - 1 elements. For each i between 0 and N - 2, inclusive, there is an edge between vertex i + 1 and vertex <b>parent</b>[i]. In a single step, Owaski can walk from a vertex to one of its adjacent vertices. You are given an vector &lt;int&gt; pleasure, element i of which indicates the pleasure Owaski gets when he reaches vertex i. Before entering the tree, his pleasure is 0. Of course, at some moments Owaski's pleasure can be negative, as some vertices can make him unhappy. However, Owaski doesn't like to be unhappy. Thus whenever his pleasure becomes negative, he will make it zero again by playing Overwatch and winning nearly every game. Owaski may enter each vertex arbitrarily many times.
However, he doesn't like old things.
Thus, if he enters a vertex he visited before, his pleasure remains unchanged.
In other words, each vertex only influences Owaski's pleasure when he visits it for the first time.</p>

Owaski enters the tree at vertex 0 (therefore the pleasure of vertex 0 also counts), and can leave the tree whenever he wants. Since all dogs love to be happy, he wants to leave with as much pleasure as possible. Return the maximal pleasure he can get.</td></tr><tr><td colspan="2"><h3>Definition</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Class:</td><td>OwaskiAndTree</td></tr><tr><td>Method:</td><td>maximalScore</td></tr><tr><td>Parameters:</td><td>vector &lt;int&gt;, vector &lt;int&gt;</td></tr><tr><td>Returns:</td><td>int</td></tr><tr><td>Method signature:</td><td>int maximalScore(vector &lt;int&gt; parent, vector &lt;int&gt; pleasure)</td></tr><tr><td colspan="2">(be sure your method is public)</td></tr></table></td></tr><tr><td colspan="2"><h3>Limits</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Time limit (s):</td><td>2.000</td></tr><tr><td>Memory limit (MB):</td><td>256</td></tr><tr><td>Stack limit (MB):</td><td>256</td></tr></table></td></tr><tr><td colspan="2"><h3>Constraints</h3></td></tr><tr><td align="center" valign="top">-</td><td><p><b>N</b> will be between 1 and 1,000, inclusive.</p></td></tr><tr><td align="center" valign="top">-</td><td><p><b>parent</b> will contain exactly <b>N</b> - 1 elements.</p></td></tr><tr><td align="center" valign="top">-</td><td><p><b>pleasure</b> will contain exactly <b>N</b> elements.</p></td></tr><tr><td align="center" valign="top">-</td><td><p>For each i, <b>parent[i]</b> will be between 0 and <b>i</b>, inclusive.</p></td></tr><tr><td align="center" valign="top">-</td><td><p>Each element of <b>pleasure</b> will be between -1,000,000 and 1,000,000, inclusive.</p></td></tr><tr><td colspan="2"><h3>Examples</h3></td></tr><tr><td align="center" nowrap="true">0)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{0, 1, 2, 3, 4, 5, 6, 7, 8}</pre></td></tr><tr><td><pre>{1, 1, -1, -1, -1, -1, 1, 1, 1, 1}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 4</pre></td></tr><tr><td><table><tr><td colspan="2">The tree forms a chain of 10 vertices and 9 edges. The optimal way is to walk through the chain. The values of pleasure of Owaski after visiting vertex 0 to 9 are 1, 2, 1, 0, 0, 0, 1, 2, 3, 4, respectively. He can leave the tree after that, yielding net pleasure of 4.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">1)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{0, 0, 1, 2}</pre></td></tr><tr><td><pre>{2, 3, 4, -1, -1}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 9</pre></td></tr><tr><td><table><tr><td colspan="2">This time his path can be 0 &rarr; 1 &rarr; 0 &rarr; 2. Note that although Owaski visits 0 twice, the pleasure of that vertex only counts once.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">2)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{0, 0, 1, 1, 2, 2, 5, 5}</pre></td></tr><tr><td><pre>{1, 2, -3, -7, 3, 2, 7, -1, 3}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 17</pre></td></tr><tr><td><table><tr><td colspan="2">One of the optimal paths is 0 &rarr; 2 &rarr; 5 &rarr; 8 &rarr; 5 &rarr; 2 &rarr; 6 &rarr; 2 &rarr; 0 &rarr; 1 &rarr; 4.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">3)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{0, 1, 1, 1, 0, 3, 1, 3, 4, 4, 3, 6, 8, 0, 12, 12, 11, 7, 7}</pre></td></tr><tr><td><pre>{-154011, 249645, 387572, 292156, -798388, 560085, -261135, -812756, 191481, -165204, 81513, -448791, 608073, 354614, -455750, 325999, 227225, -696501, 904692, -297238}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 3672275</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">4)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{}</pre></td></tr><tr><td><pre>{-1}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 0</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr></table><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc.  Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited.  (c)2003, TopCoder, Inc.  All rights reserved.  </p></body></html>
