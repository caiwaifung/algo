<html><body bgcolor="#ffffcc" text="#000000"><table><tr><td colspan="2"><h3>Problem Statement</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td>A barbarian tribe has surrounded a country. Its border has a shape of a strictly convex polygon (see notes for the exact definition) denoted by points (<b>boundaryX[i]</b>, <b>boundaryY[i]</b>) in counter-clockwise order. There are N cities strictly inside the country which we shall consider as points (<b>cityX[i]</b>, <b>cityY[i]</b>). The barbarians have spread out along the entire perimeter of the border so that the distance between consecutive barbarians (measured along the country perimeter) is always constant. It is known that one of the barbarians stands exactly at point (<b>boundaryX[0]</b>, <b>boundaryY[0]</b>). The exact number of barbarians is 1,000,000! = 1 * 2 * ... * 1,000,000. They want to divide into N equal groups such that each group attacks one particular city. There are no restrictions on the groups. In particular, a group doesn't have to contain only barbarians standing next to each other. Knowing that a barbarian walks one unit of distance in one hour, determine the minimum time in hours the last person of the last group will need to reach the cities if they divide and move optimally. Assume that barbarians and cities are points on the plane.</td></tr><tr><td colspan="2"><h3>Definition</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Class:</td><td>BarbarianInvasion2</td></tr><tr><td>Method:</td><td>minimumTime</td></tr><tr><td>Parameters:</td><td>vector &lt;int&gt;, vector &lt;int&gt;, vector &lt;int&gt;, vector &lt;int&gt;</td></tr><tr><td>Returns:</td><td>double</td></tr><tr><td>Method signature:</td><td>double minimumTime(vector &lt;int&gt; boundaryX, vector &lt;int&gt; boundaryY, vector &lt;int&gt; cityX, vector &lt;int&gt; cityY)</td></tr><tr><td colspan="2">(be sure your method is public)</td></tr></table></td></tr><tr><td colspan="2"><h3>Limits</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Time limit (s):</td><td>2.000</td></tr><tr><td>Memory limit (MB):</td><td>64</td></tr></table></td></tr><tr><td colspan="2"><h3>Notes</h3></td></tr><tr><td align="center" valign="top">-</td><td>The returned value must have an absolute or relative error less than 1e-9.</td></tr><tr><td align="center" valign="top">-</td><td>A polygon is <i>convex</i> if it does not intersect itself, and every straight line joining any two interior points of the polygon is entirely contained in the polygon's interior.</td></tr><tr><td align="center" valign="top">-</td><td>A polygon is <i>strictly convex</i> if it is convex and no three consecutive vertices lie on the same straight line.</td></tr><tr><td colspan="2"><h3>Constraints</h3></td></tr><tr><td align="center" valign="top">-</td><td><b>boundaryX</b> will contain between 3 and 50 elements, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>boundaryY</b> will contain the same number of elements as <b>boundaryX</b>.</td></tr><tr><td align="center" valign="top">-</td><td>Each element of <b>boundaryX</b> and <b>boundaryY</b> will be between -1000 and 1000, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td>The points (<b>boundaryX[i]</b>, <b>boundaryY[i]</b>), taken in order, will describe a counterclockwise traversal of vertices in a strictly convex polygon.</td></tr><tr><td align="center" valign="top">-</td><td><b>cityX</b> will contain between 1 and 5 elements, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>cityY</b> will contain the same number of elements as <b>cityX</b>.</td></tr><tr><td align="center" valign="top">-</td><td>Each element of <b>cityX</b> and <b>cityY</b> will be between -1000 and 1000, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td>The points (<b>cityX[i]</b>, <b>cityY[i]</b>) will be distinct.</td></tr><tr><td align="center" valign="top">-</td><td>The points (<b>cityX[i]</b>, <b>cityY[i]</b>) will lie strictly inside the boundary polygon.</td></tr><tr><td colspan="2"><h3>Examples</h3></td></tr><tr><td align="center" nowrap="true">0)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{0,2,2,0}</pre></td></tr><tr><td><pre>{0,0,2,2}</pre></td></tr><tr><td><pre>{1}</pre></td></tr><tr><td><pre>{1}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 1.414213562373088</pre></td></tr><tr><td><table><tr><td colspan="2">There is only one city in the country. So every barbarian will attack this city. The last barbarians to reach this city are on the corners. Each person from the corners needs square_root(2) hours to reach the city.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">1)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{0,3,3,0}</pre></td></tr><tr><td><pre>{0,0,3,3}</pre></td></tr><tr><td><pre>{1}</pre></td></tr><tr><td><pre>{1}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 2.8284271247461485</pre></td></tr><tr><td><table><tr><td colspan="2">This time, the last person is from the corner (3,3), and needs 2*square_root(2) hours to reach the city.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">2)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{0,3,3,0}</pre></td></tr><tr><td><pre>{0,0,3,3}</pre></td></tr><tr><td><pre>{1,2}</pre></td></tr><tr><td><pre>{2,1}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 2.236067977499772</pre></td></tr><tr><td><table><tr><td colspan="2">Now we have 2 cities in the country. Let's divide the barbarians into 2 groups. Group 1 consists of barbarians on borders (0,0)-(3,0) and (3,0)-(3,3). Group 2 consists of barbarians on borders (3,3)-(0,3) and (0,3)-(0,0). These 2 groups have an equal number of barbarians. The last person needs square_root(5) hours to reach the city, which is the best solution.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">3)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{0,40,40,0}</pre></td></tr><tr><td><pre>{0,0,40,40}</pre></td></tr><tr><td><pre>{1,2,31,2,15}</pre></td></tr><tr><td><pre>{1,2,3,3,24}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 38.05748153551994</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">4)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{0,124,-6,-120,-300}</pre></td></tr><tr><td><pre>{0,125,140,137,-100}</pre></td></tr><tr><td><pre>{10,10,10,10}</pre></td></tr><tr><td><pre>{50,51,52,21}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 332.77770358002783</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr></table><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc.  Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited.  (c)2003, TopCoder, Inc.  All rights reserved.  </p></body></html>
